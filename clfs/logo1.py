__author__ = 'sidon'

# Autogenerated with SMOP version
# /usr/local/bin/smop original.m

import numpy as np
from __future__ import division
try:
    from runtime import *
except ImportError:
    from smop.runtime import *

def logo(patterns=None,targets=None,parms=None,*args,**kwargs):

    varargin = cellarray(args)
    nargin = 3-[patterns,targets,parms].count(None)+len(args)

    distance=parms['distance']
    sigma=parms['sigma']
    _lambda=parms['lambda']
    plotfigure=parms['plotfigure']

    uc=np.unique(targets)

    if min_(uc) == - 1:
        targets=targets / 2 + 1.5

    new_targets=targets - 1

    dim,n_patterns=size_(patterns,nargout=2)

    for n in arange_(1,length_(uc)).reshape(-1):
        temp=find_(targets == n)
        index[n]=temp
        N[n]=length_(temp)

    Original_dim=copy_(dim)
    Original_index=arange_(1,dim)
    index_0=find_(new_targets == 0)
    History=matlabarray([])
    Weight=ones_(dim,1)
    History[:,1]=Weight
    P.lambda=_lambda
    P.Targets=Targets[:]
    Difference=1
    t=0
    theta=matlabarray([])
    while Difference > 0.01 and t <= 10:

        t=t + 1
        NM=zeros_(dim,n_patterns)
        NH=zeros_(dim,n_patterns)
        for i in arange_(1,n_patterns).reshape(-1):
            Prob_dif=0
            Prob_same=0
            for c in arange_(1,length_(uc)).reshape(-1):
                if [char('euclidean')] == lower__(distance):
                    Temp=(patterns[:,index[c]] - patterns[:,i] * ones_(1,N[c])) ** 2
                else:
                    if [char('block')] == lower__(distance):
                        Temp=abs_(patterns[:,index[c]] - patterns[:,i] * ones_(1,N[c]))
                if t == 1:
                    dist=sum_(Temp,1) / sqrt_(dim)
                else:
                    dist=(Weight[:] ** 2).T * Temp
                temp_index=find_(dist == 0)
                prob=exp_(- dist / sigma)
                if not isempty_(temp_index):
                    prob[temp_index[1]]=0
                if sum_(prob) != 0:
                    prob_1=prob / sum_(prob)
                else:
                    dum,I=sort_(dist,nargout=2)
                    prob[I[2]]=1
                    prob_1=copy_(prob)
                if targets[i] == c:
                    NH[:,i]=Temp * prob_1[:]
                if targets[i] != c:
                    NM[:,i]=NM[:,i] + Temp * prob_1[:]
        Z=NM - NH
        Z[:,index_0]=- Z[:,index_0]
        CostDiff=1000
        Cost[1]=10000
        j=1
        while CostDiff > 0.01 * Cost[j]:

            j=j + 1
            a=((Weight[:] ** 2).T) * Z
            Result=1.0 / (1 + exp_(- a))
            difference=Result[:] - new_targets[:]
            descent=(Z * difference[:]).dot(Weight) + _lambda * Weight
            P.Z=Z
            P.Weight=Weight
            P.descent=descent
            alpha,Cost[j]=fminbnd_(char('logo_cost'),0,1,optimset_(char('TolX'),0.02),P,nargout=2)
            Weight=Weight - alpha * descent
            CostDiff=abs_(Cost[j] - Cost[j - 1])

        Weight=abs_(Weight)
        Difference=norm_(abs_(Weight / max_(Weight) - History[:,t] / max_(History[:,t])))
        theta[t]=Difference
        History[:,t + 1]=Weight
        if t == 1:
            index_zeros=find_(Weight <= 10 ** (- 5))
        if t >= 2:
            index_zeros=find_(Weight <= 10 ** (- 5))
        patterns[index_zeros,:]=[]
        dim=size_(patterns,1)
        Weight[index_zeros]=[]
        History[index_zeros,:]=[]
        Original_index[index_zeros]=[]

    temp=zeros_(1,Original_dim)
    temp[Original_index]=Weight ** 2
    Weight=copy_(temp)
    if plotfigure == 1:
        figure
        semilogy_(theta,char('-o'),char('LineWidth'),1,char('MarkerFaceColor'),char('w'),char('MarkerSize'),10)
        title_(char('Theta'))
        xlabel_(char('Number of Iterations'))
        ylabel_(char('Difference'))
        grid_(char('on'))
        boldify1
        drawnow
    return Weight
